var documenterSearchIndex = {"docs":
[{"location":"tests.html#Tests","page":"Tests","title":"Tests","text":"","category":"section"},{"location":"tests.html","page":"Tests","title":"Tests","text":"This package is tested via direct comparison between the outputs of original L-BFGS and the GPU version L-BFGS.","category":"page"},{"location":"tests.html#Test-Cases","page":"Tests","title":"Test Cases","text":"","category":"section"},{"location":"tests.html","page":"Tests","title":"Tests","text":"In runtests.jl 9 tests are provided. The functionality is tested by optimizing sum of squared differences between the function outputs and a given height, which is provided as user input. One part of the tests filter the obtained minimal function value to remove any outliers as convergence issues can be common in both CPU and GPU implementations. The mean value of these correctly converged solutions is then compared between the original L-BFGS and the L-BFGS_GPU implementation. The second part of the tests compares directly the minimizers between the functions to ensure that the implementations work in the exactly same manner.","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"Quadratic SSD tests","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"beginequation\ntextSSD_textquad = sum_i=1^n (x_i^2 - y_i)^2\nendequation","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"Gaussian SSD tests","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"beginequation\ntextSSD_textgauss = sum_i=1^n left( A expleft( -frac(x_i - mu)^22 sigma^2 right) - y_i right)^2\nendequation","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"Gaussian with squared input SSD tests","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"beginequation\ntextSSD_textgauss-sq = sum_i=1^n left( A expleft( -frac(x_i^2 - mu)^22 sigma^2 right) - y_i right)^2\nendequation","category":"page"},{"location":"tests.html","page":"Tests","title":"Tests","text":"You can run test cases as usual with command : test","category":"page"},{"location":"fun_list.html#Here-is-a-very-brief-description-of-functions-defined-in-package-and-helper/testing-scripts","page":"Function list","title":"Here is a very brief description of functions defined in package and helper/testing scripts","text":"","category":"section"},{"location":"fun_list.html#functions-:-Standard-definition-for-functions","page":"Function list","title":"functions : Standard definition for functions","text":"","category":"section"},{"location":"fun_list.html#Gaussian,-Gaussian-with-squared-input,-Quadratic-function","page":"Function list","title":"Gaussian, Gaussian with squared input, Quadratic function","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Here x is the input, mu is the mean value for gaussian and std is standard deviation for gaussian. These functions return function values for respective x.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function gaussian(x::AbstractVector, mu::Number, std::Number)\nfunction gaussian(x::Number, mu::Number, std::Number)\nfunction gaussian_sq(x::AbstractVector, mu::Number, std::Number)\nfunction gaussian_sq(x::Number, mu::Number, std::Number)\nfunction quad(x::AbstractVector)\nfunction quad(x::Number)","category":"page"},{"location":"fun_list.html#These-are-the-SSD-metrics-for-respective-functions","page":"Function list","title":"These are the SSD metrics for respective functions","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Here x is the solution, givenheight is the target function value for the optimization and gausmu, gaus_std are mu and std for gaussians. These functions return the objective value for some input vector x.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function f_gaus(x::AbstractVector{T}, given_height::F, gaus_mu::G, gaus_std::H) where {T<:Number,F<:Number,G<:Number,H<:Number}\nfunction f_gaus_sq(x::AbstractVector{T}, given_height::F, gaus_mu::G, gaus_std::H) where {T<:Number,F<:Number,G<:Number,H<:Number}\nfunction f_q(x::AbstractVector{T}, given_height::F) where {T<:Number,F<:Number}","category":"page"},{"location":"fun_list.html#A-helper-structure-for-function-selection","page":"Function list","title":"A helper structure for function selection","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"struct fun_sel\n    gauss::Bool\n    gauss_sq::Bool\n    quad::Bool\nend","category":"page"},{"location":"fun_list.html#Helper-Wrapper-function-for-selection-of-the-optimization-function","page":"Function list","title":"Helper Wrapper function for selection of the optimization function","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Here fstr can be either q, g or gs for respective function selection of : Quadratic, Gaussian or Gaussian with squared input. This function returns `struct funsel` with user specified settings.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function set_selection_struct(f_str::String)","category":"page"},{"location":"fun_list.html#Helper-function-to-select-a-function-using-string-input-from-user","page":"Function list","title":"Helper function to select a function using string input from user","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Here fstr can be either q, g or gs for respective function selection of : Quadratic, Gaussian or Gaussian with squared input. The g, gs and q inputs are the anonymous functions defined in   `definefunctions(givenheight, gausmu, gaus_std)`. This function returns f, h, where f is the anonymous SSD function and h is the original actual function of interest.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function sel_opt_fun(f_str::String, g, gs, q)","category":"page"},{"location":"fun_list.html#Wrapper-function-to-define-anonymous-helper-functions","page":"Function list","title":"Wrapper function to define anonymous helper functions","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Here givenheight is the target function value for the optimization and gausmu, gaus_std are mu and std for gaussians. This function returns g, gs, q, which are the anonymous SSD objective functions.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function define_functions(given_height, gaus_mu, gaus_std)","category":"page"},{"location":"fun_list.html#Simple-constructor-for-diff-input-number-for-gaussians/quadratic","page":"Function list","title":"Simple constructor for diff input number for gaussians/quadratic","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"This function in this context is used with xvals being some range to allow drawing of the function selected by fstr. Sols are the minimizers of our optimization, gausmu, gausstd are mean and std deviation, respectively and fstr is the selection string. This function returns solvals, yvals, where solvals are the original function values for sols and yvals are function values for xvals. ","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols(x_vals::T, sols::F, gaus_mu::G, gaus_std::H, f_str::String) where {T <: AbstractArray, F <: AbstractArray, G <: Number, H <: Number}","category":"page"},{"location":"fun_list.html#Multiple-dispatch-for-gaussian","page":"Function list","title":"Multiple dispatch for gaussian","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Same return type as original eval_sols","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols_(x_vals::T, sols::F, gaus_mu::G, gaus_std::H) \nwhere {T <: AbstractArray, F <: AbstractArray, G <: Number, H <: Number}   ","category":"page"},{"location":"fun_list.html#Multiple-dispatch-for-quadratic","page":"Function list","title":"Multiple dispatch for quadratic","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Same return type as original eval_sols","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols_(x_vals::T, sols::F) where {T <: AbstractArray, F <: AbstractArray}","category":"page"},{"location":"fun_list.html#Simple-constructor-for-diff-input-number-for-gaussians/quadratic-2","page":"Function list","title":"Simple constructor for diff input number for gaussians/quadratic","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"All these are just the previous evalsols functions,  but modified very slightly to allow testing. During tests sols is used as the minimizer, gausmu,gausstd are mu and std for gaussian respectively, fstr is the selection string and orig_fun is the function we want to use in optimization (NOT THE SSD objective function).","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"This function returns sol_vals, which are the original function values for sols.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols_test(sols::F, gaus_mu::G, gaus_std::H, f_str::String, orig_fun) where {F <: AbstractArray, G <: Number, H <: Number}","category":"page"},{"location":"fun_list.html#Multiple-dispatch-for-quadratic-2","page":"Function list","title":"Multiple dispatch for quadratic","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Same return type as for original eval_sols_test function","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols_test_(sols::F, gaus_mu::G, gaus_std::H, orig_fun) where {F <: AbstractArray, G <: Number, H <: Number}","category":"page"},{"location":"fun_list.html#Multiple-dispatch-for-quadratic-3","page":"Function list","title":"Multiple dispatch for quadratic","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Same return type as for original eval_sols_test function","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function eval_sols_test_(sols::F, orig_fun) where {F <: AbstractArray}","category":"page"},{"location":"fun_list.html#Random-initial-solution-generator","page":"Function list","title":"Random initial solution generator","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Given number of initial solutions M,  minimal and maximal ranges for the random generatin minr, maxr, this generates a vector of random floats given desired properties. Returns generated Vector{Float64} of size 1xM ","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function random_init(M::Int, min_r::T, max_r::F) where {T<:Number,F<:Number}","category":"page"},{"location":"fun_list.html#Computes-the-solution-to-a-given-function-f-with-initial-solution-x0","page":"Function list","title":"Computes the solution to a given function f with initial solution x0","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"This is a helper function to be used during the optimization, where f is the objective function (in our case SSD), x0 the initial solution. Returns the  minimizer, and the minimum for given SSD objective function.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function compute_and_print(f::Function, x0::AbstractVector, verbose::Bool)","category":"page"},{"location":"fun_list.html#Simple-constructor-for-verbose-input","page":"Function list","title":"Simple constructor for verbose input","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"Same returns as the original compute_and_print function as this is a constructor for it. ","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"compute_and_print(f, x0; verbose=false) = compute_and_print(f, x0, verbose)","category":"page"},{"location":"fun_list.html#filtering-function-to-filter-correct-solutions-to-the-HEP-problem-(upto-some-tolerance)","page":"Function list","title":"filtering function to filter correct solutions to the HEP problem (upto some tolerance)","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"This function filters solution function values solvals based on some givenheight up to some tolerance. This function returns filtered_sols, filtered_vals, which are the filtered solutions and the values of these solutions respectively.","category":"page"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function filtering(sol_vals::AbstractArray, given_height tolerance::Number)","category":"page"},{"location":"fun_list.html#Base-overload-for-nice-outputs-(works-for-quadratic-and-gaussian-and-is-not-currently-used)","page":"Function list","title":"Base overload for nice outputs (works for quadratic and gaussian and is not currently used)","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function Base.show(io::IO, f_sel::fun_sel)","category":"page"},{"location":"fun_list.html#The-main-function,-which-is-correctly-described","page":"Function list","title":"The main function, which is correctly described","text":"","category":"section"},{"location":"fun_list.html#up-to-the-x::CuArray-in","page":"Function list","title":"up to the x::CuArray in","text":"","category":"section"},{"location":"fun_list.html#[Optim.jl](https://github.com/JuliaDiff/FiniteDiff.jl/blob/a7eca2d4b73c4de12140d89df7621fcc90d29190/src/gradients.jl#L165)","page":"Function list","title":"Optim.jl","text":"","category":"section"},{"location":"fun_list.html","page":"Function list","title":"Function list","text":"function FiniteDiff.finite_difference_gradient!(\n    df::StridedVector{<:Number},\n    f,\n    x::CuArray,\n    cache::FiniteDiff.GradientCache{T1,T2,T3,T4,fdtype,returntype,inplace};\n    relstep=FiniteDiff.default_relstep(fdtype, eltype(x)),\n    absstep=relstep,\n    dir=true) where {T1,T2,T3,T4,fdtype,returntype,inplace}","category":"page"},{"location":"benchmarking.html#Benchmarking-L-BFGS-Optimization-with-and-without-CUDA","page":"Benchmarking","title":"Benchmarking L-BFGS Optimization with and without CUDA","text":"","category":"section"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"The package can be used to evaluate the performance of the L-BFGS optimization method for various functions, both with and without CUDA implementation. The functions for which benchmarking can be tested out of the box are:","category":"page"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"Gaussian Function \nGaussian with Squared Input\nQuadratic Function ","category":"page"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"A single benchmarking test is performed with increasing solution sizes, and the execution time (mean and minimum) for both CPU and GPU implementations is recorded.","category":"page"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"The performance is measured using BenchmarkTools, with benchmarking being run on both CPU and GPU (using CUDA). Results, including computation times can be stored in a DataFrame format for further analysis. The optimization function is selected based on a user string input (f_str), allowing for flexible function testing.","category":"page"},{"location":"benchmarking.html#The-benchmarking-was-performed-on-MSI-GTX-980-GAMING-4G","page":"Benchmarking","title":"The benchmarking was performed on MSI GTX 980 GAMING 4G","text":"","category":"section"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"At first the CUDA version was very very fast. However the results were not really that good. This speed comparison is the first plot.","category":"page"},{"location":"benchmarking.html#Old-approach-Nice-time,-bad-results","page":"Benchmarking","title":"Old approach -> Nice time, bad results","text":"","category":"section"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"(Image: My Image)","category":"page"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"In the end i managed to repair the mistake, but at what cost. Probably due to high memory allocations for huge matrices the CUDA version is now very slow and obviously needs some optimization. You can see this sad truth on a graph below this text.","category":"page"},{"location":"benchmarking.html#New-approach-Nice-results,-bad-time","page":"Benchmarking","title":"New approach -> Nice results, bad time","text":"","category":"section"},{"location":"benchmarking.html","page":"Benchmarking","title":"Benchmarking","text":"(Image: My Image)","category":"page"},{"location":"problem.html#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem.html","page":"Problem","title":"Problem","text":"My core motivation (can show some alternative GPU use) for kernelizing L-BFGS is a real life HEP analysis problem at CERN. The problem is rather difficult to explain and to my current best knowledge it is not formalized as an official assignment in some CERN documentation yet. However you will have to trust me on this, but it can be reformulated as finding a set of input variables ","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"x_1 x_2  x_n ","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"for which a function reaches a given height (user-specified):","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"f(vecx) = textgiven_height ","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"which translates into:","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"f(vecx) - textgiven_height = 0 ","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"We formulate the objective function as:","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"f_textopt = textSSD(f(vecx) textgiven_height) ","category":"page"},{"location":"problem.html","page":"Problem","title":"Problem","text":"where SSD is the sum of squared differences, making L-BFGS an ideal solver for such problem.","category":"page"},{"location":"solution.html#Solution-to-L-BFGS-kernelization","page":"Solution","title":"Solution to L-BFGS kernelization","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"The implementation that solves the CUDA incompatibility is in /src/Optim_dispatch.jl.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Key modifications:","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Array → CuArray conversion\nAvoiding scalar indexing (as it reduces GPU parallelism)\nCorrectly using broadcasting (.) instead of loops","category":"page"},{"location":"solution.html#Example-fix:","page":"Solution","title":"Example fix:","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"x .= x .+ epsilon  # Instead of for loops","category":"page"},{"location":"solution.html#Example-solutions-to-underlying-HEP-problem","page":"Solution","title":"Example solutions to underlying HEP problem","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"As the solutions to higher dimensional problem tend to be hard to vizualize, I have selected 3 nonlinear one dimensional functions to serve as proof of concept. As we optimize at the same time over 500 variables, it can be seen as highly-multinomial optimization. The tested functions are listed below.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Quadratic function\nGaussian function\nGaussian function with squared input","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"500 solutions were computed using L-BFGS with CUDA and filtered so that only converged solutions were visible. The convergence issue has nothing to do with GPU as this happens also with the base L-BFGS. ","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"This can be seen in \\scripts\\draw_sols.jl, where user can interactively choose drawn function and parameters of the functions.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"After 1 run of L-BFGS with CUDA the solutions are shown here for each respective function.","category":"page"},{"location":"solution.html","page":"Solution","title":"Solution","text":"As the underlying problem does not require precise solution, but rather an interval in which we should do additional computations, this filtering method is quite suitable for this specific problem.","category":"page"},{"location":"solution.html#Gaussian-for-height-0.25","page":"Solution","title":"Gaussian for height = 0.25","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"(Image: My Image)","category":"page"},{"location":"solution.html#Gaussian-with-squared-input-for-height-0.25","page":"Solution","title":"Gaussian with squared input for height = 0.25","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"(Image: My Image)","category":"page"},{"location":"solution.html#Quadratic-function-for-height-40","page":"Solution","title":"Quadratic function for height = 40","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"(Image: My Image)","category":"page"},{"location":"ack.html","page":"Acknowledgements","title":"Acknowledgements","text":"I would like to thank my cat Luděk for his undying support in the last few days. He did not have it easy as I often programmed instead of eating and forgor to give him food as well. He will be given a complementary snack while you are reading this documentation.","category":"page"},{"location":"index.html#L-BFGS-GPU-Documentation","page":"Home","title":"L-BFGS GPU Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the L-BFGS GPU documentation. This package provides a GPU implementation of the L-BFGS solver from Optim.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"info: Info\nFor installation and usage, see the sections below.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Since L-BFGS GPU is not a registered Julia package, you need to install it directly from its GitHub repository. To do this, open the Julia REPL and run:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/matouon/lbfgsgpu.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Alternatively, you can activate the package in an environment:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.activate(\".\")\nPkg.add(url=\"https://github.com/matouon/lbfgsgpu.jl\")","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To use L-BFGS GPU, first load the package:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using lbfgsgpu","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then, you can call the solver in the same manner as L-BFGS, but with CuArray instead of Array type of the initial solution. An example use can be seen Example slidebar or in the actual package in /scripts/lbfgs_test.jl","category":"page"},{"location":"index.html#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"L-BFGS GPU The dependencies to run an example as described in the Example section are listed below","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add([\"Optim\", \"CUDA\", \"Random\"])\nPkg.add(url=\"https://github.com/matouon/lbfgsgpu.jl\")\n","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Optim.jl Documentation\nCUDA.jl Documentation","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For further assistance, open an issue on the GitHub repository.","category":"page"},{"location":"example.html#Example:-Using-LBFGS-for-Optimization","page":"Example","title":"Example: Using LBFGS for Optimization","text":"","category":"section"},{"location":"example.html","page":"Example","title":"Example","text":"This example demonstrates how to use LBFGS() for optimization in Julia. A random initial solution is generated and a simple quadratic function is then optimized. ","category":"page"},{"location":"example.html#Setup","page":"Example","title":"Setup","text":"","category":"section"},{"location":"example.html","page":"Example","title":"Example","text":"To run this example, ensure you have the required packages installed:","category":"page"},{"location":"example.html","page":"Example","title":"Example","text":"using Pkg\nPkg.add([\"Optim\", \"CUDA\", \"Random\"])\nPkg.add(url=\"https://github.com/matouon/lbfgsgpu.jl\")\n","category":"page"},{"location":"example.html","page":"Example","title":"Example","text":"Example code below on minimizing a SSD of 3 quadratic functions (M=3).","category":"page"},{"location":"example.html","page":"Example","title":"Example","text":"using Optim\nusing CUDA\nusing lbfgsgpu\nusing Random\n\nfunction gaussian(x::AbstractVector, mu::Number, std::Number)\n    (1 / (std * sqrt(2 * pi))) * exp.(-((x .- mu) .^ 2) / (2 * std^2))\nend\n\nfunction gaussian(x::Number, mu::Number, std::Number)\n    (1 / (std * sqrt(2 * pi))) * exp.(-((x - mu) ^ 2) / (2 * std^2))\nend\n# Randomly initialize solution\nfunction random_init(M::Int, min_r::T, max_r::T) where {T<:Number}\n    return rand(M) .* (max_r - min_r) .+ min_r\nend\n\n# Compute solution using LBFGS\nfunction compute_and_print(f::Function, x0::AbstractVector)\n    res = optimize(f, x0, LBFGS())\n    println(\"Minimum f(x): \", Optim.minimum(res))\n    return Optim.minimizer(res)\nend\n\n#Gaussian gaussian with squared input\nfunction f_gaus_sq(x::AbstractVector{T}, given_height::F, gaus_mu::G, gaus_std::H) where {T<:Number,F<:Number,G<:Number,H<:Number}\n    # Compute the sum of the squared differences for all elements\n    return sum((gaussian(x .^ 2, gaus_mu, gaus_std) .- given_height).^2)\nend\n\n# Initialize parameters\nM, min_r, max_r = 3, -10, 10\ngaus_mu = 1\ngaus_std = 1\n\nx0 = random_init(M, min_r, max_r)\n\ngiven_height = 0.25  # given_height value for function\nf = x -> f_gaus_sq(x, given_height, gaus_mu, gaus_std)\n\n# Run optimization\ncompute_and_print(f, x0)\ncompute_and_print(f, CuArray(x0))","category":"page"}]
}
